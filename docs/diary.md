/**
 * @file: Diary.md
 * @description: Дневник наблюдений и решений по проекту обработки текста с ИИ.
 * @dependencies: None
 * @created: 2024-07-29
 */

# Дневник проекта

## [2024-07-29]

### Наблюдения
- Получен запрос на интеграцию ИИ для исправления специфичных типов ошибок (опечатки, пунктуация, дефисы, кавычки) в тексте, проверяемом скриптом `tools/check_text_languagetool.py`.
- LanguageTool предоставляет детальную информацию об ошибках, включая их тип и положение в тексте. Эту информацию можно использовать для формирования контекста для ИИ.
- Необходимо обеспечить, чтобы вызовы к ИИ были эффективными и не перегружали систему, особенно при обработке больших текстов.

### Решения
- Будет добавлена новая функция в `check_text_languagetool.py`, которая будет вызывать API OpenRouter (модель qwen/qwen3-235b-a22b:free) для получения предложений по исправлению ошибок.
- В JSON-отчет, генерируемый скриптом, будет добавлено новое поле (например, `ai_suggestion`) для каждой ошибки, по которой ИИ предоставил исправление. Это поле будет содержать предложенный ИИ текст.
- На данном этапе прямое применение исправлений в HTML-файл не реализуется. Вместо этого, пользователь сможет видеть предложенные исправления в отчете.
- Для взаимодействия с OpenRouter будет использоваться библиотека `openai` (она позволяет указывать `base_url` для совместимых API).
- Определить список категорий ошибок LanguageTool, которые будут кандидатами на исправление с помощью ИИ (например, `TYPOS`, `PUNCTUATION`, `CASING`, некоторые `STYLE` или `GRAMMAR` ошибки, связанные с дефисами/кавычками).

### Проблемы
- **Контекст для ИИ**: Важно определить, какой объем контекста (окружающий текст) необходимо передавать ИИ для качественного исправления. Слишком малый контекст может привести к некорректным исправлениям, слишком большой - к увеличению времени обработки и стоимости запросов (если модель не бесплатная или имеет лимиты).
- **Производительность**: Даже бесплатные модели могут иметь ограничения по частоте запросов. Необходимо продумать стратегию (например, кэширование запросов для одинаковых ошибок, возможность пакетной обработки).
- **Точность ИИ**: ИИ не всегда может давать 100% корректные исправления. Важно, чтобы пользователь имел возможность просмотреть и утвердить исправления.
- **Обработка HTML**: При передаче текста в ИИ и получении исправлений, необходимо аккуратно обращаться с HTML-тегами, чтобы не повредить структуру документа. На текущем этапе это решается тем, что исправления только предлагаются, а не применяются автоматически в HTML.

## 2024-07-27

### Наблюдения

*   Начало проекта. Определены основные цели и задачи: создание системы обработки текста с помощью ИИ для последующего макетирования и вывода в форматах PDF, Epub, HTML.
*   Проанализирован список предложенных бесплатных ИИ моделей. Для текущих задач проекта наиболее перспективной выглядит модель Qwen: Qwen3 235B A22B из-за ее высокой производительности, многоязычности, способности следовать инструкциям и большого контекстного окна.
*   Создана базовая структура документации в папке `docs/`, включая `Project.md`, `Tasktracker.md`, `Diary.md`, `qa.md`, `changelog.md`.
*   В `Project.md` заложено предварительное описание архитектуры, которая включает модули загрузки, ИИ-обработки (анализ и трансформация), макетирования и вывода. Также определены предварительные этапы разработки и технологический стек.
*   В `Tasktracker.md` внесены задачи первого этапа: "Проектирование и настройка окружения".

### Решения

*   Принять за основу для дальнейшего планирования ИИ модель **Qwen: Qwen3 235B A22B**. Необходимо будет детальнее изучить ее API и возможности интеграции.
*   Продолжить детализацию архитектуры, особенно интерфейсов между модулями и выбор конкретных технологий для бэкенда и фронтенда.
*   В качестве первоочередных задач определить настройку среды разработки и создание базовой структуры исходного кода проекта.

### Проблемы

*   На данном этапе явных проблем не выявлено. Основной вызов - сложность и многогранность проекта, требующая тщательного планирования и последовательной реализации.
*   Необходимо будет провести более глубокое исследование библиотек для генерации PDF и Epub, чтобы выбрать наиболее подходящие и совместимые с PrinceXML (если он будет основным инструментом для PDF).

## 2024-07-29

### Наблюдения
- Уточнён и зафиксирован детализированный pipeline автоматизированной обработки художественного текста: загрузка → конвертация в HTML → LanguageTool (автоматические исправления) → ИИ-обработка (автоматические исправления и дополнения) → Typograf → конвертация обратно в docx.
- Принцип: все этапы должны быть максимально автоматизированы, ручная доработка допускается только в случае критических ошибок.

### Решения
- Каждый этап реализуется отдельным модулем с чётким API.
- Все промежуточные файлы и логи сохраняются для аудита.
- В дальнейшем возможна интеграция очереди задач для пакетной обработки.

### Проблемы
- Не выявлено. Возможные сложности — корректность автоматических исправлений на больших объёмах художественного текста.

## [2024-07-05]
### Наблюдения
- Взаимодействие между модулями pipeline будет осуществляться через файловую систему.
- Каждый этап получает на вход файл определённого формата и сохраняет результат в отдельный файл.
- Именование файлов стандартизировано для отслеживания этапов.

### Решения
- Описаны форматы входных и выходных файлов для каждого этапа pipeline.
- Определена структура рабочей директории и правила именования файлов.
- Принято решение валидировать входные файлы на каждом этапе и логировать ошибки.

### Проблемы
- Возможные ошибки при конвертации и потере форматирования требуют ручной доработки на критических этапах.

## [Дата]

### Наблюдения
Был успешно спроектирован и "реализован" (в рамках симуляции) первый прототип системы. 
Прототип включает:
- Оркестратор (`src/pipeline/orchestrator.py`): управляет потоком, генерирует `correlation_id`, обрабатывает ошибки модулей.
- Модуль конвертации DOCX->HTML (`src/pipeline/docx_to_html_converter.py`): использует `pandoc`, логирует, создает статус-файлы.
- Модуль-заглушку обработки текста (`src/pipeline/text_processor_stub.py`): имитирует работу, также с логированием и статус-файлами.
- Вспомогательные утилиты: `src/utils/exceptions.py` для пользовательских исключений и `src/utils/logger_setup.py` для настройки JSON-логгера с контекстом.
- Определена структура рабочих директорий (`workspace/`) для входных, промежуточных файлов и логов.
- Создан `requirements.txt`.

Прототип демонстрирует:
- Передачу файлов между модулями.
- Использование `correlation_id` для сквозного отслеживания.
- Запись логов в JSON формате.
- Создание статус-файлов для каждого этапа.
- Базовую обработку ошибок.

### Решения
1.  Использовать `pandoc` для конвертации DOCX в HTML.
2.  Применять JSON-формат для логов и статус-файлов.
3.  Создавать отдельные директории для каждого запуска (`correlation_id`) и каждого этапа в `workspace/processing/`.
4.  Реализовать модульный подход с четким разделением ответственности.

### Проблемы
- На данном этапе симуляции не выявлено. Реальные проблемы могут возникнуть при фактическом запуске и тестировании, особенно связанные с доступностью `pandoc`, правами доступа или спецификой различных `.docx` файлов.

## [Дата]

### Наблюдения
Принято решение сфокусироваться на проектировании системы обработки ошибок, логирования и валидации данных как следующем приоритетном шаге. Это заложит основу для стабильной работы всех последующих модулей. В `Project.md` добавлены соответствующие разделы, детализирующие подходы. В `Tasktracker.md` создана новая задача для отслеживания этого процесса.

### Решения
1.  Приоритезировать разработку механизмов обработки ошибок, логирования и валидации.
2.  Детализировать в `Project.md` стратегии для каждого из этих аспектов.

### Проблемы
- На данном этапе не выявлено.

*(Этот документ будет обновляться по мере развития проекта)*

## 2024-07-30

### Наблюдения
- Прототип CLI-конвейера был успешно запущен после решения ряда проблем с настройкой окружения и импортами Python.
- Основной проблемой была корректная активация виртуального окружения и обеспечение того, чтобы Python использовал зависимости из этого окружения.
- Также возникла проблема с импортом `logging.handlers`, которая была решена явным импортом этого подмодуля.
- Логика работы оркестратора была изменена: входные файлы теперь ожидаются в директории `textinput/`, а имя файла передается как аргумент командной строки.

### Решения
1.  **Изменение директории входных файлов:** Оркестратор (`src/pipeline/orchestrator.py`) модифицирован для работы с файлами из директории `textinput/` и получения имени файла через `argparse`.
2.  **Устранение `ImportError` (относительные импорты):** Запуск оркестратора теперь выполняется как модуль (`python3 -m src.pipeline.orchestrator`) из корневой директории проекта, что решает проблемы с относительными импортами.
3.  **Устранение `ModuleNotFoundError: No module named 'pythonjsonlogger'`:** Проблема была связана с неактивным виртуальным окружением. Переустановка пакета `python-json-logger` в активном окружении решила проблему.
4.  **Устранение `AttributeError: module 'logging' has no attribute 'handlers'`:** В `src/utils/logger_setup.py` добавлен явный импорт `import logging.handlers`.
5.  **Создание `__init__.py`:** Пустые файлы `__init__.py` были добавлены в `src/`, `src/pipeline/` и `src/utils/` для обеспечения корректной работы Python с этими директориями как с пакетами.

### Проблемы
- Изначально были сложности с правильной диагностикой проблем импорта, так как `sys.path` и `which python3` показывали корректные пути, но модуль все равно не находился до принудительной переустановки и последующего решения с `logging.handlers`.
- Процесс отладки потребовал нескольких итераций проверки активации окружения.

*(Этот документ будет обновляться по мере развития проекта)*

## 2024-07-31
### Наблюдения
- Реализованы и интегрированы модули автокоррекции (AutocorrectProcessorModule), типографики (TypografProcessorModule) и конвертации HTML в DOCX (HtmlToDocxProcessorModule).
- orchestrator.py теперь управляет всеми этапами пайплайна, логированием и статусами.
- Пайплайн обновлён: автокоррекция теперь реализуется только на этапе AutocorrectProcessorModule, каждое исправление подтверждается LLM (OpenRouter).
- LanguageToolProcessorModule больше не вызывает LLM, только анализирует и формирует отчёт.
- Возникла необходимость сохранять итоговый HTML-файл, который используется для конвертации в docx, pdf, epub и другие форматы, для целей аудита и прозрачности.
- Ранее промежуточные HTML-файлы не сохранялись, что затрудняло анализ финального состояния текста перед экспортом.

### Решения
- Каждый модуль сохраняет результат и служебный SUCCESS.json.
- Пайплайн полностью автоматизирован: от проверки текста до финального DOCX.
- Исключена дублирующая работа LLM на этапе LanguageTool.
- Вся логика применения исправлений и подтверждения LLM теперь централизована в AutocorrectProcessorModule.
- Принято решение: итоговый HTML-файл перед конвертацией в любой формат должен сохраняться в директории output под именем final.html.
- Это правило распространяется на все форматы вывода.
- Промежуточные (draft) HTML-файлы сохранять не требуется.

### Проблемы
- Необходима актуализация пайплайна и тестирование корректности сохранения файла на всех этапах экспорта.

*(Этот документ будет обновляться по мере развития проекта)*

## 31.07.2024

### Наблюдения
- Реализовано сохранение итогового HTML файла в директории output
- Добавлена новая константа OUTPUT_DIR для хранения итоговых файлов
- Расширен формат статуса пайплайна для включения информации об итоговом HTML

### Решения
- Использован модуль shutil для надежного копирования файла с сохранением метаданных
- Выбрано фиксированное имя final.html для итогового файла
- Добавлено логирование операций с итоговым HTML файлом

### Проблемы
- Нет текущих проблем, все изменения реализованы успешно

## [2024-07-31] Сохранение HTML с именем исходного файла

### Наблюдения
- Для аудита и прозрачности требуется сохранять HTML-файл, используемый для конвертации, с именем исходного файла (docx → html)

### Решения
- После этапа автокоррекции HTML-файл копируется в workspace/output/ с именем исходного файла, но с расширением .html
- Статус пайплайна обновлён для отражения этого пути

### Проблемы
- Нет

## [2024-07-31] Интеграция пайплайна с webapp

### Наблюдения
- Веб-интерфейс Flask теперь напрямую запускает orchestrator.py для обработки загруженных файлов.
- Очередь и статусы реализованы через Python queue и file_registry.json.
- Итоговый DOCX-файл копируется в results/ и доступен для скачивания.

### Решения
- Использовать subprocess для запуска orchestrator.py из воркера Flask.
- Обновлять статусы и ссылки на результат в file_registry.json.

### Проблемы
- Нет